<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поиск слов: Основы Информационной Безопасности</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px 10px;
            background-color: #f0f0f0;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #game-container {
            display: flex;
            gap: 30px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            width: auto;
            max-width: calc(100% - 20px); 
            align-items: flex-start;
        }

        #grid-container {
            user-select: none;
             /* Динамический размер сетки может потребовать прокрутки, если станет очень большой */
            overflow: auto; /* Добавим на всякий случай, если сетка будет огромной */
            max-width: 100%; /* Чтобы не вылезала за пределы game-container на мобильных */
        }

        #letter-grid {
            border-collapse: collapse;
            margin: 0 auto; /* Центрирование таблицы, если она меньше grid-container */
        }

        #letter-grid td {
            width: 30px; /* Базовый размер, может адаптироваться */
            height: 30px;
            border: 1px solid #ccc;
            text-align: center;
            font-size: 16px; /* Чуть уменьшим для потенциально более плотной сетки */
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            background-color: #fff;
            color: #333;
        }

        #letter-grid td.selected {
            background-color: #add8e6;
        }

        #letter-grid td.found {
            background-color: #90ee90;
            color: #145a32;
            font-weight: bold;
        }
        
        #letter-grid td.found.selected {
            background-color: #add8e6; 
            color: #333; 
        }

        #questions-container {
            max-width: 400px;
            min-width: 300px; 
            display: flex;
            flex-direction: column;
        }
        
        h2 {
            color: #333;
            text-align: center;
            margin-top: 0; 
            margin-bottom: 10px;
            font-size: 20px;
            flex-shrink: 0;
        }

        #questions-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
        }

        #questions-list li {
            padding: 8px 5px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
            transition: color 0.3s ease, background-color 0.3s ease;
            color: #555;
            line-height: 1.4;
        }
        
        #questions-list li:last-child {
            border-bottom: none;
        }

        #questions-list li.question-found {
            color: #28a745;
            text-decoration: line-through;
            font-weight: bold;
            background-color: #e6ffe6;
        }
        
        #win-message {
            text-align: center;
            font-size: 24px;
            color: #28a745;
            margin-top: 20px;
        }
        #restart-button-container {
            text-align: center;
            margin-top: 15px;
        }
        #restart-button {
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #restart-button:hover {
            background-color: #0056b3;
        }


        /* Адаптивность для мобильных устройств */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 15px;
            }

            #game-container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
                padding: 15px;
                max-width: 100%;
            }

            #grid-container {
                /* overflow-x: auto; уже есть выше, и этого достаточно */
                width: 100%; 
            }

            #letter-grid td {
                 /* Если сетка 10x10, 28px может быть нормально. Если больше, то размер ячеек может понадобиться уменьшить */
                 width: 28px; /* Динамически можно менять в JS, если сетка больше */
                 height: 28px;
                 font-size: 14px; 
            }

            #questions-container {
                max-width: 100%;
                width: 100%;
                min-width: unset;
                margin-top: 0;
                max-height: none; 
            }

            #questions-list {
                overflow-y: visible; 
                padding-right: 0;
                font-size: 13px;
            }
            
            #win-message {
                font-size: 20px;
            }
        }
        @media (max-width: 480px) { /* Для очень маленьких экранов */
            h1 {
                font-size: 18px;
            }
             #letter-grid td {
                 /*width: 25px; 
                 height: 25px;
                 font-size: 12px; */
                 /* Эти размеры могут стать слишком мелкими, если сетка 15x15. 
                    Лучше, чтобы #grid-container просто скроллился */
            }
            #questions-list li {
                font-size: 12px;
                padding: 6px 3px;
            }
        }
    </style>
</head>
<body>
    <h1>Поиск слов: Основы Информационной Безопасности</h1>
    
    <div id="game-container">
        <div id="grid-container">
            <table id="letter-grid"></table>
        </div>
        <div id="questions-container">
            <h2>Вопросы:</h2>
            <ul id="questions-list"></ul>
        </div>
    </div>

    <div id="win-message" style="display:none;">
        Поздравляем! Вы нашли все слова!
        <div id="restart-button-container">
            <button id="restart-button">Играть снова</button>
        </div>
    </div>

    <script>
        const SIMPLE_QA_RAW = [
            { q: "Проект отечественного квантово-устойчивого алгоритма ЭЦП для стандартизации", a: "Гиперикум" }, // 9
            // { q: "Алгоритм, стойкий к атакам квантового компьютера", a: "Постквантовый" }, // 13
            // { q: "Свойство безопасности данных, которое обеспечивает шифрование", a: "Конфиденциальность" }, // 19
            // { q: "Свойство безопасности данных, которое обеспечивает хэширование", a: "Целостность" }, // 11
            { q: "Шифровальная машина, которую взломал Алан Тьюринг", a: "Энигма" }, // 6
            { q: "Ситуация, когда два разных текста дают одинаковый хэш", a: "Коллизия" }, // 8
            { q: "Название нового отечественного алгоритма блочного шифрования", a: "Кузнечик" }, // 8
            { q: "Название старого отечественного алгоритма блочного шифрования", a: "Магма" },   // 5
            { q: "Название отечественного алгоритма функции хэширования", a: "Стрибог" }, // 7
            { q: "Случайные данные, добавляемые к паролю перед хэшированием", a: "Соль" },    // 4
            { q: "Метод проверки подлинности пользователя по биологическим признакам", a: "Биометрия" }, // 9
            { q: "Метод, позволяющий проверить подлинность данных без шифрования", a: "Подпись" }, // 7
            { q: "Физическое устройство, используемое для упрощения аутентификации", a: "Токен" },   // 5
            { q: "Цепочка блоков с защищенными от изменений данными на основе хэш-функций", a: "Блокчейн" },// 9
            { q: "Секретная информация, необходимая для расшифрования или подписи", a: "Ключ" },    // 4
            { q: "Специалист по созданию алгоритмов шифрования", a: "Криптограф" },// 10
            { q: "Устройство или программа для шифрования данных", a: "Шифратор" }, // 8
            { q: "Секретная комбинация символов для получения доступа к различным данным", a: "Пароль" },  // 6
            { q: "Тип ключа, позволяющий подписывать сообщения", a: "Секретный" }, // 9
            { q: "Тип ключа, позволяющий проверять подпись сообщения", a: "Открытый" }  // 8
        ];

        const COMPLEX_QA_RAW = [
            // { q: "Вид шифрования данных с сохранением свойств операций сложения и умножения для шифртекстов", a: "Гомоморфное" }, // 11
            { q: "Область постквантовой криптографии к которой относится стандарт Kyber/ML-KEM", a: "Решетки" }, // 7
            // { q: "Процедура проверки подлинности", a: "Аутентификация" }, // 15
            { q: "Область постквантовой криптографии к которой криптосистема Мак-Элиса", a: "Коды" }, // 4
            // { q: "Алгоритм разложения числа на множители", a: "Факторизация" }, // 12
            { q: "Фамилия автора алгоритма для взлома RSA с помощью квантового компьютера", a: "Шор" }, // 3
            { q: "Квантовый алгоритм, дающий квадратичное ускорение атаки перебором", a: "Гровер" }, // 6
            { q: "Криптографическая функция, преобразующая данные в строку фиксированной длины", a: "Хэш" } // 3
        ];

        const NUM_SIMPLE_QUESTIONS = 4;
        const NUM_COMPLEX_QUESTIONS = 1;
        const BASE_GRID_DIMENSION = 10; // Минимальный размер сетки 10x10
        const MAX_PLACEMENT_ATTEMPTS_PER_WORD = 200; // Увеличим, т.к. сетка может быть плотнее

        let CURRENT_QUIZ_QA_LIST = []; // Вопросы для текущей игры
        let GRID_ROWS = BASE_GRID_DIMENSION;
        let GRID_COLS = BASE_GRID_DIMENSION;

        let grid = []; 
        let selectedCells = []; 
        let placedWordsData = []; // Это будет подмножество CURRENT_QUIZ_QA_LIST, которое удалось разместить

        const alphabet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";

        // Функция для перемешивания массива (Fisher-Yates shuffle)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function selectQuizQuestions() {
            shuffleArray(SIMPLE_QA_RAW);
            shuffleArray(COMPLEX_QA_RAW);

            const selectedSimple = SIMPLE_QA_RAW.slice(0, NUM_SIMPLE_QUESTIONS);
            const selectedComplex = COMPLEX_QA_RAW.slice(0, NUM_COMPLEX_QUESTIONS);
            
            CURRENT_QUIZ_QA_LIST = [...selectedSimple, ...selectedComplex].map((item, index) => ({
                question: item.q,
                answer: item.a.toUpperCase().replace(/\s+/g, ''),
                originalAnswer: item.a,
                id: `question-${index}-${item.a.toUpperCase().replace(/\s+/g, '').replace(/[^A-ZА-Я0-9]/ig, '')}`, // Добавим индекс для уникальности ID
                found: false,
                cells: [] 
            }));
            shuffleArray(CURRENT_QUIZ_QA_LIST); // Перемешаем итоговый список для случайного порядка в UI
            console.log("Selected questions for this quiz:", CURRENT_QUIZ_QA_LIST.map(q => q.originalAnswer));
        }

        function determineGridSize() {
            let maxLength = 0;
            CURRENT_QUIZ_QA_LIST.forEach(qa => {
                if (qa.answer.length > maxLength) {
                    maxLength = qa.answer.length;
                }
            });

            // Даем небольшой запас, чтобы слова не были впритык к краям, и было место для других.
            // +2 или +3 к максимальной длине слова.
            // И чтобы было место для 5 слов, даже если они все короткие.
            // Пытаемся сохранить примерно квадратную форму.
            const totalLetters = CURRENT_QUIZ_QA_LIST.reduce((sum, qa) => sum + qa.answer.length, 0);
            const estimatedMinArea = totalLetters * 2; // Примерная площадь с учетом "мусора"
            
            let dimension = Math.max(BASE_GRID_DIMENSION, maxLength + 1); // +1 чтобы слово не было впритык
            
            // Убедимся, что площадь сетки достаточна для размещения
            // (очень грубая оценка, т.к. размещение сложное)
            while (dimension * dimension < estimatedMinArea && dimension < 30) { // Ограничим максимальный размер сетки
                dimension++;
            }
            // Если самое длинное слово очень большое, оно определяет размер
            dimension = Math.max(dimension, maxLength + 1);


            GRID_ROWS = dimension;
            GRID_COLS = dimension;
            console.log(`Determined grid size: ${GRID_ROWS}x${GRID_COLS} (maxLengthWord: ${maxLength})`);
        }
        
        function resetGame() {
            selectedCells = [];
            placedWordsData = [];
            CURRENT_QUIZ_QA_LIST = [];
            document.getElementById('win-message').style.display = 'none';
            // Удаляем старые обработчики, если они были (на всякий случай, хотя renderGrid их пересоздает)
            const oldGridCells = document.querySelectorAll('#letter-grid td');
            oldGridCells.forEach(td => {
                const newTd = td.cloneNode(true); // Клонируем без обработчиков
                td.parentNode.replaceChild(newTd, td);
            });
            initGame();
        }


        function initGame() {
            console.log("Initializing new game...");
            selectQuizQuestions();
            if (CURRENT_QUIZ_QA_LIST.length === 0) {
                alert("Ошибка: не удалось выбрать вопросы для игры.");
                return;
            }
            determineGridSize();
            
            prepareGridData();
            renderGrid();
            renderQuestions();

            if (placedWordsData.length < CURRENT_QUIZ_QA_LIST.length) {
                 console.warn(`Could only place ${placedWordsData.length} out of ${CURRENT_QUIZ_QA_LIST.length} selected words. Grid might be too small or placement too difficult.`);
                 // Можно добавить сообщение пользователю, если не все слова размещены, но это усложнит игру.
                 // Для теста из 5 слов это должно быть редкой ситуацией при адекватном размере сетки.
            }
            if (placedWordsData.length === 0 && CURRENT_QUIZ_QA_LIST.length > 0) {
                 console.error("CRITICAL: No words were placed from the selected quiz words.");
                 alert("Критическая ошибка: не удалось разместить ни одного слова на сетке. Попробуйте перезапустить игру.");
            }
        }


        function getRandomLetter() {
            return alphabet[Math.floor(Math.random() * alphabet.length)];
        }

        function prepareGridData() {
            grid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
            placedWordsData = []; // Сбрасываем перед каждой попыткой генерации

            // Сортируем слова для размещения по убыванию длины
            const wordsToPlaceThisTurn = [...CURRENT_QUIZ_QA_LIST].sort((a, b) => b.answer.length - a.answer.length);

            wordsToPlaceThisTurn.forEach(qaItem => {
                const word = qaItem.answer;
                if (word.length > GRID_ROWS && word.length > GRID_COLS) {
                    console.error(`Word "${word}" is too long for the current grid (${GRID_ROWS}x${GRID_COLS}). Skipping.`);
                    return; // Пропускаем слово, если оно не может поместиться даже по диагонали (хотя диагоналей нет)
                }

                let placed = false;
                for (let attempt = 0; attempt < MAX_PLACEMENT_ATTEMPTS_PER_WORD && !placed; attempt++) {
                    const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                    let r_start, c_start;
                    let wordCellsCoords = [];

                    if (direction === 'horizontal') {
                        if (word.length > GRID_COLS) continue; // Не поместится горизонтально
                        r_start = Math.floor(Math.random() * GRID_ROWS);
                        c_start = Math.floor(Math.random() * (GRID_COLS - word.length + 1));
                    } else { // vertical
                        if (word.length > GRID_ROWS) continue; // Не поместится вертикально
                        r_start = Math.floor(Math.random() * (GRID_ROWS - word.length + 1));
                        c_start = Math.floor(Math.random() * GRID_COLS);
                    }

                    let canPlace = true;
                    for (let i = 0; i < word.length; i++) {
                        const curR = direction === 'horizontal' ? r_start : r_start + i;
                        const curC = direction === 'horizontal' ? c_start + i : c_start;
                        
                        if (grid[curR][curC] !== null && grid[curR][curC] !== word[i]) {
                            canPlace = false;
                            break;
                        }
                    }

                    if (canPlace) {
                        for (let i = 0; i < word.length; i++) {
                            const curR = direction === 'horizontal' ? r_start : r_start + i;
                            const curC = direction === 'horizontal' ? c_start + i : c_start;
                            grid[curR][curC] = word[i];
                            wordCellsCoords.push({ r: curR, c: curC });
                        }
                        
                        // qaItem уже содержит id, question, answer, originalAnswer, found (false)
                        // Мы добавляем/обновляем 'cells' и 'direction'
                        const placedWordEntry = {...qaItem, cells: wordCellsCoords, direction: direction};
                        placedWordsData.push(placedWordEntry);
                        placed = true;
                    }
                }
                if (!placed) {
                    console.warn(`Could not place word: ${word} after ${MAX_PLACEMENT_ATTEMPTS_PER_WORD} attempts.`);
                }
            });

            // Заполняем оставшиеся пустые ячейки случайными буквами
            for (let r_fill = 0; r_fill < GRID_ROWS; r_fill++) {
                for (let c_fill = 0; c_fill < GRID_COLS; c_fill++) {
                    if (grid[r_fill][c_fill] === null) {
                        grid[r_fill][c_fill] = getRandomLetter();
                    }
                }
            }
        }

        function renderGrid() {
            const gridTable = document.getElementById('letter-grid');
            gridTable.innerHTML = ''; // Очищаем предыдущую сетку
            // Адаптация размера ячеек, если сетка большая
            let cellSize = 30;
            if (GRID_COLS > 15 || GRID_ROWS > 15) {
                cellSize = 25;
            }
            if (GRID_COLS > 20 || GRID_ROWS > 20) {
                cellSize = 22;
            }


            for (let r_render = 0; r_render < GRID_ROWS; r_render++) {
                const tr = document.createElement('tr');
                for (let c_render = 0; c_render < GRID_COLS; c_render++) {
                    const td = document.createElement('td');
                    td.textContent = grid[r_render][c_render];
                    td.dataset.r = r_render;
                    td.dataset.c = c_render;
                    td.style.width = `${cellSize}px`;
                    td.style.height = `${cellSize}px`;
                    td.style.fontSize = `${Math.max(10, cellSize - 10)}px`; // Адаптивный размер шрифта
                    td.addEventListener('click', handleCellClick);
                    tr.appendChild(td);
                }
                gridTable.appendChild(tr);
            }
        }

        function renderQuestions() {
            const questionsUl = document.getElementById('questions-list');
            questionsUl.innerHTML = '';
            
            // Отображаем вопросы из CURRENT_QUIZ_QA_LIST, но состояние found берем из placedWordsData
            // (так как не все слова из CURRENT_QUIZ_QA_LIST могли быть размещены,
            // хотя в идеале должны быть все 5)
            const placedAnswersMap = new Map(placedWordsData.map(pwd => [pwd.answer, pwd]));

            let questionNumber = 1;
            CURRENT_QUIZ_QA_LIST.forEach(quizQaItem => {
                const li = document.createElement('li');
                li.textContent = `${questionNumber}. ${quizQaItem.question}`;
                li.id = quizQaItem.id; // Используем ID из CURRENT_QUIZ_QA_LIST

                // Проверяем, было ли это слово размещено и найдено
                const placedVersion = placedAnswersMap.get(quizQaItem.answer);
                if (placedVersion && placedVersion.found) {
                    li.classList.add('question-found');
                } else if (!placedVersion) {
                    // Слово не было размещено, можно его как-то пометить (например, серым цветом)
                    // или просто не добавлять, но тогда нарушится условие "5 вопросов"
                    // li.style.color = "lightgray"; 
                    // li.title = "Это слово не удалось разместить на сетке";
                    // Пока просто отображаем, как будто оно есть
                }
                questionsUl.appendChild(li);
                questionNumber++;
            });
        }
        
        function handleCellClick(event) {
            const clickedTd = event.target;
            // Если игра окончена, не обрабатываем клики
            if (document.getElementById('win-message').style.display === 'block') {
                return;
            }

            const r_click = parseInt(clickedTd.dataset.r);
            const c_click = parseInt(clickedTd.dataset.c);

            const cellIndexInSelection = selectedCells.findIndex(cell => cell.td === clickedTd);

            if (cellIndexInSelection > -1) {
                clickedTd.classList.remove('selected');
                selectedCells.splice(cellIndexInSelection, 1);
            } else {
                clickedTd.classList.add('selected');
                selectedCells.push({ td: clickedTd, r: r_click, c: c_click, letter: clickedTd.textContent });
            }
            checkSelectedWord();
        }

        function getSubsets(array, size) {
            const result = [];
            const temp = [];
            function findSubsetsRecursive(start) {
                if (temp.length === size) {
                    result.push([...temp]);
                    return;
                }
                if (start === array.length) {
                    return;
                }
                temp.push(array[start]);
                findSubsetsRecursive(start + 1);
                temp.pop();
                findSubsetsRecursive(start + 1);
            }
            findSubsetsRecursive(0);
            return result;
        }

        function checkSelectedWord() {
            if (selectedCells.length === 0) return;
            
            for (const wordData of placedWordsData) { // Итерируем только по реально размещенным словам
                if (wordData.found) continue;

                const targetWordString = wordData.answer;
                const targetWordCellsOnGrid = wordData.cells; 

                if (selectedCells.length < targetWordString.length) {
                    continue;
                }

                const potentialSubsets = getSubsets(selectedCells, targetWordString.length);

                for (const subset of potentialSubsets) {
                    const subsetCoordsCanonical = subset.map(sc => `${sc.r},${sc.c}`).sort().join(';');
                    const targetWordCellsCanonical = targetWordCellsOnGrid.map(tc => `${tc.r},${tc.c}`).sort().join(';');

                    if (subsetCoordsCanonical === targetWordCellsCanonical) {
                        let formedWordFromSubset = "";
                        let lettersAreCorrect = true;
                        for (const targetGridCell of targetWordCellsOnGrid) {
                            const matchingCellInSubset = subset.find(subCell => subCell.r === targetGridCell.r && subCell.c === targetGridCell.c);
                            if (matchingCellInSubset) {
                                formedWordFromSubset += matchingCellInSubset.letter;
                            } else {
                                lettersAreCorrect = false; 
                                break;
                            }
                        }
                        
                        if (lettersAreCorrect && (formedWordFromSubset === targetWordString || formedWordFromSubset.split('').reverse().join('') === targetWordString)) {
                            wordData.found = true; // Помечаем found у элемента в placedWordsData

                            subset.forEach(cellObj => {
                                cellObj.td.classList.remove('selected');
                                cellObj.td.classList.add('found');
                            });

                            selectedCells.forEach(originalCellObj => {
                                if (!subset.some(subCell => subCell.td === originalCellObj.td)) {
                                    originalCellObj.td.classList.remove('selected');
                                }
                            });
                            
                            const questionLi = document.getElementById(wordData.id); // ID из wordData (который пришел из CURRENT_QUIZ_QA_LIST)
                            if (questionLi) {
                                questionLi.classList.add('question-found');
                            } else {
                                console.warn("Could not find question LI for ID:", wordData.id, "Word:", wordData.originalAnswer);
                            }
                            
                            selectedCells = []; 
                            checkWinCondition();
                            return; 
                        }
                    }
                } 
            } 
        }
        
        function checkWinCondition() {
            // Проверяем, все ли слова из placedWordsData найдены.
            // Если какое-то слово из CURRENT_QUIZ_QA_LIST не было размещено, оно не повлияет на победу.
            // Победа наступает, когда все УСПЕШНО РАЗМЕЩЕННЫЕ слова найдены.
            const allPlacedWordsFound = placedWordsData.length > 0 && placedWordsData.every(word => word.found);
            
            if (allPlacedWordsFound) {
                const winMessageDiv = document.getElementById('win-message');
                winMessageDiv.style.display = 'block';
                // Можно заблокировать дальнейшие клики, добавив класс на grid-container или через JS
                // Но handleCellClick уже проверяет это.
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            initGame();
            document.getElementById('restart-button').addEventListener('click', resetGame);
        });

    </script>
</body>
</html>