<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поиск слов: Информационная Безопасность PHD2025</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px 10px;
            background-color: #f0f0f0;
            min-height: 100vh;
            box-sizing: border-box;
        }

        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
            font-size: 24px;
        }

        #game-container {
            display: flex;
            gap: 30px;
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            flex-wrap: wrap;
            width: auto;
            max-width: calc(100% - 20px); 
            align-items: flex-start;
        }

        #grid-container {
            user-select: none;
        }

        #letter-grid {
            border-collapse: collapse;
        }

        #letter-grid td {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            background-color: #fff;
            color: #333;
        }

        #letter-grid td.selected {
            background-color: #add8e6;
        }

        #letter-grid td.found {
            background-color: #90ee90;
            color: #145a32;
            font-weight: bold;
        }
        
        #letter-grid td.found.selected {
            background-color: #add8e6; 
            color: #333; 
        }

        #questions-container {
            max-width: 400px;
            min-width: 300px; /* Для десктопа, чтобы не слишком сужался */
            display: flex;
            flex-direction: column;
            /* Убираем ограничение высоты и скролл для десктопа */
            /* max-height: calc(100vh - 150px); -- УБРАНО */
        }
        
        h2 {
            color: #333;
            text-align: center;
            margin-top: 0; 
            margin-bottom: 10px;
            font-size: 20px;
            flex-shrink: 0;
        }

        #questions-list {
            list-style-type: none;
            padding: 0;
            margin: 0;
            /* flex-grow: 1; -- Не так актуально без ограничения высоты родителя */
            /* overflow-y: auto; -- УБРАНО для десктопа, скроллится вся страница */
        }

        #questions-list li {
            padding: 8px 5px;
            border-bottom: 1px solid #eee;
            font-size: 14px;
            transition: color 0.3s ease, background-color 0.3s ease;
            color: #555;
            line-height: 1.4;
        }
        
        #questions-list li:last-child {
            border-bottom: none;
        }

        #questions-list li.question-found {
            color: #28a745;
            text-decoration: line-through;
            font-weight: bold;
            background-color: #e6ffe6;
        }
        
        #win-message {
            text-align: center;
            font-size: 24px;
            color: #28a745;
            margin-top: 20px;
        }

        /* Адаптивность для мобильных устройств */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 15px;
            }

            #game-container {
                flex-direction: column;
                align-items: center;
                gap: 20px;
                padding: 15px;
                max-width: 100%;
            }

            #grid-container {
                overflow-x: auto;
                width: 100%;
            }

            #letter-grid td {
                 width: 28px; 
                 height: 28px;
                 font-size: 15px; 
            }

            #questions-container {
                max-width: 100%;
                width: 100%;
                min-width: unset;
                margin-top: 0;
                max-height: none; /* На мобильных список растягивается, скроллится вся страница */
            }

            #questions-list {
                overflow-y: visible; /* Чтобы не было двойного скролла на мобильных */
                padding-right: 0;
                font-size: 13px;
            }
            
            #win-message {
                font-size: 20px;
            }
        }
        @media (max-width: 480px) {
            h1 {
                font-size: 18px;
            }
             #letter-grid td {
                 width: 25px; 
                 height: 25px;
                 font-size: 14px; 
            }
            #questions-list li {
                font-size: 12px;
                padding: 6px 3px;
            }
        }
    </style>
</head>
<body>
    <h1>Поиск слов: Основы Информационной Безопасности PHD2025</h1>
    
    <div id="game-container">
        <div id="grid-container">
            <table id="letter-grid"></table>
        </div>
        <div id="questions-container">
            <h2>Вопросы:</h2>
            <ul id="questions-list"></ul>
        </div>
    </div>

    <div id="win-message" style="display:none;">Поздравляем! Вы нашли все слова!</div>

    <script>
        const QA_LIST_RAW = [
            { q: "Проект отечественного квантово-устойчивого алгоритма ЭЦП для стандартизации", a: "Гиперикум" },
            { q: "Алгоритм, стойкий к атакам квантового компьютера", a: "Постквантовый" },
            { q: "Свойство безопасности данных, которое обеспечивает шифрование", a: "Конфиденциальность" },
            { q: "Свойство безопасности данных, которое обеспечивает хэширование", a: "Целостность" },
            { q: "Мошенничество через поддельные письма или сайты", a: "Фишинг" },
            { q: "Сетевой фильтр, блокирующий опасный трафик", a: "Фаервол" },
            { q: "Процедура проверки подлинности", a: "Аутентификация" },
            { q: "Программа для поиска и удаления вредоносного ПО", a: "Антивирус" },
            { q: "Подбор паролей перебором", a: "Брутфорс" },
            { q: "Тестирование безопасности системы на проникновение", a: "Пентест" },
            { q: "Шифровальная машина, которую взломал Алан Тьюринг", a: "Энигма" },
            { q: "Ситуация, когда два разных текста дают одинаковый хэш", a: "Коллизия" },
            { q: "Название нового отечественного алгоритма блочного шифрования", a: "Кузнечик" },
        //     { q: "Название старого отечественного алгоритма блочного шифрования", a: "Магма" },
        //     { q: "Название отечественного алгоритма функции хэширования", a: "Стрибог" },
        //     { q: "Случайные данные, добавляемые к паролю перед хэшированием", a: "Соль" },
        //     { q: "Метод проверки подлинности пользователя по биологическим признакам", a: "Биометрия" },
        //     { q: "Программа, маскирующаяся под легитимное ПО", a: "Троян" },
        //     { q: "Криптографическая функция, преобразующая данные в строку фиксированной длины", a: "Хэш" },
        //     { q: "Метод, позволяющий проверить подлинность данных без шифрования", a: "Подпись" },
        //     { q: "Вредоносный код, заражающий файлы", a: "Вирус" },
        //     { q: "Физическое устройство, используемое для упрощения аутентификации", a: "Токен" },
        //     { q: "Цепочка блоков с защищенными от изменений данными на основе хэш-функций", a: "Блокчейн" },
        //     { q: "Секретная информация, необходимая для расшифрования или подписи", a: "Ключ" },
        //     { q: "Массовая рассылка нежелательных сообщений", a: "Спам" },
        //     { q: "Специалист по созданию алгоритмов шифрования", a: "Криптограф" },
        //     { q: "Устройство или программа для шифрования данных", a: "Шифратор" },
        //     { q: "Уникальный идентификатор пользователя в системе", a: "Логин" },
        //     { q: "Алгоритм разложения числа на множители", a: "Факторизация" },
        //     { q: "Секретная комбинация символов для получения доступа к различным данным", a: "Пароль" },
        //     { q: "Область постквантовой криптографии к которой относится стандарт Kyber/ML-KEM", a: "Решетки" },
        //     { q: "Область постквантовой криптографии к которой криптосистема Мак-Элиса", a: "Коды" },
        //     { q: "Фамилия автора алгоритма для взлома RSA с помощью квантового компьютера", a: "Шор" },
        //     { q: "Вид шифрования данных с сохранением свойств операций сложения и умножения для шифртекстов", a: "Гомоморфное" }
        ];

        const QA_LIST = QA_LIST_RAW.map(item => ({
            question: item.q,
            answer: item.a.toUpperCase().replace(/\s+/g, ''),
            originalAnswer: item.a,
            id: `question-${item.a.toUpperCase().replace(/\s+/g, '').replace(/[^A-ZА-Я0-9]/ig, '')}`,
            found: false,
            cells: [] 
        }));

        const GRID_ROWS = 25; 
        const GRID_COLS = 25;
        const MAX_PLACEMENT_ATTEMPTS = 100;

        let grid = []; 
        let selectedCells = []; 
        let placedWordsData = []; 

        const alphabet = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";

        function initGame() {
            console.log("Initializing game...");
            prepareGridData();
            renderGrid();
            renderQuestions();
            console.log("Game initialized. Placed words:", placedWordsData.length, "/", QA_LIST.length);
            if (placedWordsData.length < QA_LIST.length) {
                 console.warn(`Could only place ${placedWordsData.length} out of ${QA_LIST.length} words. Consider increasing grid size or placement attempts.`);
            }
            if (placedWordsData.length === 0 && QA_LIST.length > 0) {
                 console.error("CRITICAL: No words were placed. Check grid size or placement logic.");
                 alert("Ошибка: не удалось разместить слова на сетке. Пожалуйста, проверьте консоль для деталей или увеличьте размер сетки в коде (GRID_ROWS, GRID_COLS).");
            }
        }

        function getRandomLetter() {
            return alphabet[Math.floor(Math.random() * alphabet.length)];
        }

        function prepareGridData() {
            grid = Array(GRID_ROWS).fill(null).map(() => Array(GRID_COLS).fill(null));
            placedWordsData = [];

            const wordsToPlace = [...QA_LIST].sort((a, b) => b.answer.length - a.answer.length);

            wordsToPlace.forEach(qaItem => {
                const word = qaItem.answer;
                let placed = false;
                for (let attempt = 0; attempt < MAX_PLACEMENT_ATTEMPTS && !placed; attempt++) {
                    const direction = Math.random() < 0.5 ? 'horizontal' : 'vertical';
                    let r_start, c_start; // r, c - зарезервированы в selectedCells, лучше использовать другие имена
                    let wordCellsCoords = [];

                    if (direction === 'horizontal') {
                        r_start = Math.floor(Math.random() * GRID_ROWS);
                        c_start = Math.floor(Math.random() * (GRID_COLS - word.length + 1));
                    } else {
                        r_start = Math.floor(Math.random() * (GRID_ROWS - word.length + 1));
                        c_start = Math.floor(Math.random() * GRID_COLS);
                    }

                    let canPlace = true;
                    for (let i = 0; i < word.length; i++) {
                        const curR = direction === 'horizontal' ? r_start : r_start + i;
                        const curC = direction === 'horizontal' ? c_start + i : c_start;
                        
                        if (grid[curR][curC] !== null && grid[curR][curC] !== word[i]) {
                            canPlace = false;
                            break;
                        }
                    }

                    if (canPlace) {
                        for (let i = 0; i < word.length; i++) {
                            const curR = direction === 'horizontal' ? r_start : r_start + i;
                            const curC = direction === 'horizontal' ? c_start + i : c_start;
                            grid[curR][curC] = word[i];
                            wordCellsCoords.push({ r: curR, c: curC });
                        }
                        
                        const placedWordEntry = {...qaItem, cells: wordCellsCoords, direction: direction};
                        placedWordsData.push(placedWordEntry);

                        const originalQaItem = QA_LIST.find(item => item.answer === qaItem.answer);
                        if (originalQaItem) {
                            originalQaItem.cells = wordCellsCoords; // Обновляем и в исходном списке для консистентности
                        }
                        placed = true;
                    }
                }
                if (!placed) {
                    console.warn(`Could not place word: ${word}`);
                }
            });

            for (let r_fill = 0; r_fill < GRID_ROWS; r_fill++) {
                for (let c_fill = 0; c_fill < GRID_COLS; c_fill++) {
                    if (grid[r_fill][c_fill] === null) {
                        grid[r_fill][c_fill] = getRandomLetter();
                    }
                }
            }
        }

        function renderGrid() {
            const gridTable = document.getElementById('letter-grid');
            gridTable.innerHTML = '';
            for (let r_render = 0; r_render < GRID_ROWS; r_render++) {
                const tr = document.createElement('tr');
                for (let c_render = 0; c_render < GRID_COLS; c_render++) {
                    const td = document.createElement('td');
                    td.textContent = grid[r_render][c_render];
                    td.dataset.r = r_render;
                    td.dataset.c = c_render;
                    td.addEventListener('click', handleCellClick);
                    tr.appendChild(td);
                }
                gridTable.appendChild(tr);
            }
        }

        function renderQuestions() {
            const questionsUl = document.getElementById('questions-list');
            questionsUl.innerHTML = '';
            const placedMap = new Map(placedWordsData.map(pwd => [pwd.answer, pwd]));
            let questionNumber = 1;
            QA_LIST.forEach(originalQaItem => {
                if (placedMap.has(originalQaItem.answer)) {
                    const wordData = placedMap.get(originalQaItem.answer);
                    const li = document.createElement('li');
                    li.textContent = `${questionNumber}. ${wordData.question}`;
                    li.id = wordData.id;
                    if (wordData.found) {
                        li.classList.add('question-found');
                    }
                    questionsUl.appendChild(li);
                    questionNumber++;
                }
            });
        }
        
        function handleCellClick(event) {
            const clickedTd = event.target;
            const r_click = parseInt(clickedTd.dataset.r);
            const c_click = parseInt(clickedTd.dataset.c);

            const cellIndexInSelection = selectedCells.findIndex(cell => cell.td === clickedTd);

            if (cellIndexInSelection > -1) {
                clickedTd.classList.remove('selected');
                selectedCells.splice(cellIndexInSelection, 1);
            } else {
                clickedTd.classList.add('selected');
                selectedCells.push({ td: clickedTd, r: r_click, c: c_click, letter: clickedTd.textContent });
            }
            checkSelectedWord();
        }

        // Вспомогательная функция для получения всех подмножеств заданного размера
        function getSubsets(array, size) {
            const result = [];
            const temp = [];
            function findSubsets(start) {
                if (temp.length === size) {
                    result.push([...temp]);
                    return;
                }
                if (start === array.length) {
                    return;
                }
                // Включаем текущий элемент
                temp.push(array[start]);
                findSubsets(start + 1);
                // Исключаем текущий элемент (бэктрекинг)
                temp.pop();
                findSubsets(start + 1);
            }
            findSubsets(0);
            return result;
        }


        // --- ОБНОВЛЕННАЯ ЛОГИКА `checkSelectedWord` ---
        function checkSelectedWord() {
            if (selectedCells.length === 0) return;

            // Сортируем слова для проверки от самых длинных из возможных в selectedCells к коротким.
            // Это может помочь найти более длинное слово раньше, если оно полностью выбрано.
            // (Но основной перебор идет по placedWordsData)
            
            for (const wordData of placedWordsData) {
                if (wordData.found) continue;

                const targetWordString = wordData.answer;
                const targetWordCellsOnGrid = wordData.cells; // [{r,c}, ...]

                // Если выбранных ячеек меньше, чем букв в слове, его точно не найти
                if (selectedCells.length < targetWordString.length) {
                    continue;
                }

                // Получаем все подмножества selectedCells, размер которых равен длине targetWordString
                const potentialSubsets = getSubsets(selectedCells, targetWordString.length);

                for (const subset of potentialSubsets) {
                    // subset - это массив из {td, r, c, letter}
                    
                    // 1. Проверка по координатам (каноническое представление)
                    const subsetCoordsCanonical = subset
                        .map(sc => `${sc.r},${sc.c}`)
                        .sort()
                        .join(';');
                    
                    const targetWordCellsCanonical = targetWordCellsOnGrid
                        .map(tc => `${tc.r},${tc.c}`)
                        .sort()
                        .join(';');

                    if (subsetCoordsCanonical === targetWordCellsCanonical) {
                        // Наборы координат совпадают! Это значит, что ячейки из `subset`
                        // - это те же самые ячейки, что и `targetWordCellsOnGrid`.

                        // 2. Проверка букв (чтобы убедиться, что они образуют слово)
                        // Собираем слово из `subset`, используя порядок `targetWordCellsOnGrid`
                        let formedWordFromSubset = "";
                        let lettersAreCorrect = true;
                        for (const targetGridCell of targetWordCellsOnGrid) { // Идем по ячейкам слова в правильном порядке
                            const matchingCellInSubset = subset.find(subCell => subCell.r === targetGridCell.r && subCell.c === targetGridCell.c);
                            if (matchingCellInSubset) {
                                formedWordFromSubset += matchingCellInSubset.letter;
                            } else {
                                // Этого не должно случиться, если канонические представления координат совпали
                                lettersAreCorrect = false; 
                                break;
                            }
                        }
                        
                        if (lettersAreCorrect && (formedWordFromSubset === targetWordString || formedWordFromSubset.split('').reverse().join('') === targetWordString)) {
                            // Слово найдено!
                            wordData.found = true;

                            // Помечаем ячейки найденного слова (из subset) как 'found'
                            subset.forEach(cellObj => {
                                cellObj.td.classList.remove('selected');
                                cellObj.td.classList.add('found');
                            });

                            // Снимаем выделение 'selected' с "лишних" ячеек,
                            // которые были в selectedCells, но не вошли в найденный subset.
                            selectedCells.forEach(originalCellObj => {
                                if (!subset.some(subCell => subCell.td === originalCellObj.td)) {
                                    originalCellObj.td.classList.remove('selected');
                                }
                            });
                            
                            const questionLi = document.getElementById(wordData.id);
                            if (questionLi) {
                                questionLi.classList.add('question-found');
                            }
                            
                            selectedCells = []; // Полностью очищаем текущий выбор пользователя
                            checkWinCondition();
                            return; // Слово найдено и обработано
                        }
                    }
                } // конец цикла по подмножествам
            } // конец цикла по wordData
        }
        
        function checkWinCondition() {
            const allFound = placedWordsData.length > 0 && placedWordsData.every(word => word.found);
            if (allFound) {
                const winMessageDiv = document.getElementById('win-message');
                winMessageDiv.style.display = 'block';
                const gridCells = document.querySelectorAll('#letter-grid td');
                gridCells.forEach(td => td.removeEventListener('click', handleCellClick));
            }
        }

        document.addEventListener('DOMContentLoaded', initGame);

    </script>
</body>
</html>